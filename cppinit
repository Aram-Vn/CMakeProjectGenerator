#!/usr/bin/python

import os
import subprocess
from typing import List
from typing import Dict
import sys
import shutil


class ProjectContent:
    def __init__(self, new_project_name: str):
        self.project_name = new_project_name
    #________________________________-main_cpp-________________________________#
        self.main_cpp_content: str = f"""
#include <iostream>
#include <logger.hpp>
#include <{self.project_name}.h>

int main()
{{
    my::{self.project_name} a{{}};
    log_debug("YES: %i\\n", a.p);
    return 0;
}}
        """

    #________________________________-header_file-________________________________#
        self.header_file_content: str = f"""
#ifndef __{self.project_name.upper()}_INCLUDE_{self.project_name.upper()}_H__
#define __{self.project_name.upper()}_INCLUDE_{self.project_name.upper()}_H__

namespace my {{
    class {self.project_name} {{
    public:
    {self.project_name}();

    int p;
    }};
}} // namespace my

#endif // __{self.project_name.upper()}_INCLUDE_{self.project_name.upper()}_H__
        """

    #________________________________-src_file-________________________________#
        self.src_file_content: str = f"""
#include "../include/{self.project_name}.h"

namespace my {{
    {self.project_name}::{self.project_name}() : p(42) {{}}
}} // namespace my
        """

    #________________________________-.git_ignore_content-________________________________#
        self.git_ignore_content: str = """
build/
compile_commands.json
.vscode
.cache

# Prerequisites
*.d

# C++ objects and libs
*.slo
*.lo
*.o
*.a
*.la
*.lai
*.so
*.so.*
*.dll
*.dylib

# Precompiled Headers
*.gch
*.pch

# Compiled Dynamic libraries
*.so
*.dylib
*.dll

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai
*.la
*.a
*.lib

# Executables
*.exe
*.out
*.app

"""

    #________________________________-.CMakeLists.txt__root-________________________________#
        self.cmake_list_root: str = f"""
cmake_minimum_required(VERSION 3.10)

project("{self.project_name}")

set(TARGET_NAME app_${{PROJECT_NAME}})
set(CMAKE_EXPORT_COMPILE_COMMANDS on)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

file(GLOB_RECURSE SOURCE_FILES 
    src/*.cpp
)

file(GLOB_RECURSE HEADER_FILES 
    include/*.h
)

add_executable(${{TARGET_NAME}} 
    main.cpp  
    ${{SOURCE_FILES}} 
    ${{HEADER_FILES}}
)

target_include_directories(${{TARGET_NAME}}
    PRIVATE 
        ${{CMAKE_CURRENT_SOURCE_DIR}}/include
)

include(CTest)
add_subdirectory(tests)
add_subdirectory(logger)

set(COMMON_COMPILE_OPTIONS
    -Wall
    -Wextra
    -Wshadow
    -Wswitch
    -pedantic
    -Wformat=2
    -Wnull-dereference
    -Wunused-parameter
    -Wunreachable-code
    -Wimplicit-fallthrough
)

set(COMMON_ERROR_OPTIONS
    -Werror
    -Werror=return-type
    -Werror=uninitialized
    -Werror=unused-result
    -Werror=strict-overflow
)

set(SANITIZER_FLAGS
    -fsanitize=undefined
    -fsanitize=address
    # -fsanitize=thread 
    -fsanitize=address
    -fno-omit-frame-pointer
)

target_compile_options(${{TARGET_NAME}} PRIVATE
    ${{COMMON_COMPILE_OPTIONS}}
    ${{COMMON_ERROR_OPTIONS}}
)

target_link_libraries(${{TARGET_NAME}} PRIVATE
    ${{SANITIZER_FLAGS}}
    one_header_logger
)

target_compile_definitions(one_header_logger INTERFACE
    LOG_LEVEL_THRESHOLD=LOG_LEVEL_DEBUG
    ENABLE_LOG_MUTEX
)

#-----------------------------------------------------------------------#
# if need to remove flags set lib as SYSTEM 
# to suppress warnings in external headers
#-----------------------------------------------------------------------#
# Remove -pedantic from the targetâ€™s options 
# get_target_property(target_options ${{TARGET_NAME}} COMPILE_OPTIONS)
# list(REMOVE_ITEM target_options "-pedantic")
# list(REMOVE_ITEM target_options "-Werror")
# set_property(TARGET ${{TARGET_NAME}} PROPERTY COMPILE_OPTIONS ${{target_options}})

# If not Visual Studio generator, copy compile_commands.json
if(NOT CMAKE_GENERATOR MATCHES "Visual Studio")
    add_custom_command(
        OUTPUT ${{CMAKE_CURRENT_SOURCE_DIR}}/compile_commands.json
        COMMAND ${{CMAKE_COMMAND}} -E copy ${{CMAKE_BINARY_DIR}}/compile_commands.json ${{CMAKE_CURRENT_SOURCE_DIR}}/compile_commands.json
        DEPENDS ${{CMAKE_BINARY_DIR}}/compile_commands.json
        COMMENT "Copying compile_commands.json..."
    )

    add_custom_target(copy_compile_commands ALL
        DEPENDS ${{CMAKE_CURRENT_SOURCE_DIR}}/compile_commands.json
    )
endif()
        """

    #________________________________-.CMakeLists.txt__test-________________________________#
        self.cmake_list_test_content: str = f"""
cmake_minimum_required(VERSION 3.10)

project({self.project_name}_test)

find_package(GTest QUIET)

if(NOT GTest_FOUND)
    message(STATUS "[...] GTest not found. Attempting to install using package manager...")
    if(UNIX AND NOT APPLE)
        execute_process(
            COMMAND sh -c "sudo apt-get install -y libgtest-dev || sudo dnf install -y gtest-devel || 
                           sudo pacman -S --noconfirm gtest || yay -S --noconfirm gtest"
            RESULT_VARIABLE PACKAGE_INSTALL_RESULT
            OUTPUT_VARIABLE PACKAGE_INSTALL_OUTPUT
            ERROR_VARIABLE PACKAGE_INSTALL_ERROR
        )
    elseif(APPLE)
        execute_process(
            COMMAND brew install googletest
            RESULT_VARIABLE PACKAGE_INSTALL_RESULT
            OUTPUT_VARIABLE PACKAGE_INSTALL_OUTPUT
            ERROR_VARIABLE PACKAGE_INSTALL_ERROR
        )
    elseif(WIN32)
        execute_process(
            COMMAND powershell -Command "scoop install gtest"
            RESULT_VARIABLE PACKAGE_INSTALL_RESULT
            OUTPUT_VARIABLE PACKAGE_INSTALL_OUTPUT
            ERROR_VARIABLE PACKAGE_INSTALL_ERROR
        )
    else()
        set(PACKAGE_INSTALL_RESULT -1)
    endif()

    if(PACKAGE_INSTALL_RESULT EQUAL 0) 
        find_package(GTest QUIET)

        if(GTest_FOUND)
            message(STATUS "[ V ] Successfully installed GTest using the package manager.")
        else()
            message(WARNING "[ X ] Installation via package manager was successful, but GTest could not be found.")
        endif()
    else()
        message(WARNING "[ X ] Failed to install GTest using the package manager.")
        message(STATUS "[ X ] Package manager output: ${{PACKAGE_INSTALL_OUTPUT}}")
        message(STATUS "[ X ] Package manager error: ${{PACKAGE_INSTALL_ERROR}}")
    endif()
endif()

include_directories(${{GTEST_INCLUDE_DIRS}})
include_directories(${{CMAKE_SOURCE_DIR}}/include)  

file(GLOB_RECURSE SRC_FILES "${{CMAKE_SOURCE_DIR}}/src/*.cpp")
file(GLOB_RECURSE HDR_FILES "${{CMAKE_SOURCE_DIR}}/include/*.h")

add_executable({self.project_name}_test {self.project_name}_test.cpp)

target_include_directories({self.project_name}_test PRIVATE ${{CMAKE_SOURCE_DIR}}/include)
target_link_libraries({self.project_name}_test ${{GTEST_LIBRARIES}} ${{GTEST_MAIN_LIBRARIES}} pthread)

enable_testing()
add_test(NAME {self.project_name}_test COMMAND {self.project_name}_test)
target_compile_options({self.project_name}_test PRIVATE -Wall)
        """

        self.test_file_content: str = f"""
#include <{self.project_name}.h>
#include <gtest/gtest.h>

TEST({self.project_name}Test, {self.project_name}Test__1) 
{{}}

int main(int argc, char** argv)
{{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}}
        """

    #________________________________-.logger.hpp-________________________________#

        self.logger_hpp_conten: str = """
#pragma once

#undef log

#define LOG_LEVEL_DEBUG 0
#define LOG_LEVEL_INFO  1
#define LOG_LEVEL_WARN  2
#define LOG_LEVEL_ERROR 3

// Default to INFO if not defined by compiler flags
#ifndef LOG_LEVEL_THRESHOLD
#define LOG_LEVEL_THRESHOLD 0
#endif

#ifdef _WIN32
#include <windows.h>

static auto _ = []
{
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == INVALID_HANDLE_VALUE)
        return 0;

    DWORD dwMode = 0;
    if (!GetConsoleMode(hOut, &dwMode))
        return 0;

    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    SetConsoleMode(hOut, dwMode);
    return 0;
}();
#endif

#define COLOR(x) x
#define RED      COLOR("\033[1;31m")
#define YELLOW   COLOR("\033[1;33m")
#define GREEN    COLOR("\033[1;32m")
#define BLUE     COLOR("\033[1;34m")
#define RESET    COLOR("\033[0m")

#ifdef ENABLE_LOG_MUTEX
#include <mutex>
inline std::mutex log_mutex;
#define LOCK_LOG()           std::lock_guard<std::mutex> lock(log_mutex)
#define IS_LOG_MUTEX_ENABLED 1
#else
#define LOCK_LOG()           (void)0
#define IS_LOG_MUTEX_ENABLED 0
#endif

#if defined(__GNUC__) && !defined(__clang__)
// GNU-style macro with ##__VA_ARGS__
#define log(level, fmt, ...)                                                                                           \
    do                                                                                                                 \
    {                                                                                                                  \
        LOCK_LOG();                                                                                                    \
        const char* lvl_str = (level == LOG_LEVEL_ERROR)  ? "[" RED "ERROR" RESET "]"                                  \
                              : (level == LOG_LEVEL_WARN) ? "[" YELLOW "WARN" RESET "]"                                \
                              : (level == LOG_LEVEL_INFO) ? "[" GREEN "INFO" RESET "]"                                 \
                                                          : "[" BLUE "DEBUG" RESET "]";                                \
        if (level == LOG_LEVEL_INFO || level == LOG_LEVEL_DEBUG)                                                       \
        {                                                                                                              \
            fprintf(stderr, "%s ", lvl_str);                                                                           \
        }                                                                                                              \
        else                                                                                                           \
        {                                                                                                              \
            fprintf(stderr, "%s %s:%d %s(): ", lvl_str, __FILE__, __LINE__, __func__);                                 \
        }                                                                                                              \
        fprintf(stderr, fmt, ##__VA_ARGS__);                                                                           \
    } while (0)
#else
// C++ standard-compliant version
#define log(level, ...)                                                                                                \
    do                                                                                                                 \
    {                                                                                                                  \
        LOCK_LOG();                                                                                                    \
        const char* lvl_str = (level == LOG_LEVEL_ERROR)  ? "[" RED "ERROR" RESET "]"                                  \
                              : (level == LOG_LEVEL_WARN) ? "[" YELLOW "WARN" RESET "]"                                \
                              : (level == LOG_LEVEL_INFO) ? "[" GREEN "INFO" RESET "]"                                 \
                                                          : "[" BLUE "DEBUG" RESET "]";                                \
        if (level == LOG_LEVEL_INFO || level == LOG_LEVEL_DEBUG)                                                       \
        {                                                                                                              \
            fprintf(stderr, "%s ", lvl_str);                                                                           \
        }                                                                                                              \
        else                                                                                                           \
        {                                                                                                              \
            fprintf(stderr, "%s %s:%d %s(): ", lvl_str, __FILE__, __LINE__, __func__);                                 \
        }                                                                                                              \
        fprintf(stderr, __VA_ARGS__);                                                                                  \
    } while (0)
#endif

#if LOG_LEVEL_DEBUG >= LOG_LEVEL_THRESHOLD
#define log_debug(...) log(LOG_LEVEL_DEBUG, __VA_ARGS__)
#define log_once_debug(...)                                                                                            \
    do                                                                                                                 \
    {                                                                                                                  \
        static bool _once = false;                                                                                     \
        if (!_once)                                                                                                    \
        {                                                                                                              \
            _once = true;                                                                                              \
            log(LOG_LEVEL_DEBUG, __VA_ARGS__);                                                                         \
        }                                                                                                              \
    } while (0)
#else
#define log_debug(...) (void)0
#endif

#if LOG_LEVEL_INFO >= LOG_LEVEL_THRESHOLD
#define log_info(...) log(LOG_LEVEL_INFO, __VA_ARGS__)
#define log_once_info(...)                                                                                             \
    do                                                                                                                 \
    {                                                                                                                  \
        static bool _once = false;                                                                                     \
        if (!_once)                                                                                                    \
        {                                                                                                              \
            _once = true;                                                                                              \
            log(LOG_LEVEL_INFO, __VA_ARGS__);                                                                          \
        }                                                                                                              \
    } while (0)
#else
#define log_info(...)      (void)0
#define log_once_info(...) (void)0
#endif

#if LOG_LEVEL_WARN >= LOG_LEVEL_THRESHOLD
#define log_warn(...) log(LOG_LEVEL_WARN, __VA_ARGS__)
#define log_once_warn(...)                                                                                             \
    do                                                                                                                 \
    {                                                                                                                  \
        static bool _once = false;                                                                                     \
        if (!_once)                                                                                                    \
        {                                                                                                              \
            _once = true;                                                                                              \
            log(LOG_LEVEL_WARN, __VA_ARGS__);                                                                          \
        }                                                                                                              \
    } while (0)
#else
#define log_warn(...) (void)0
#endif

#if LOG_LEVEL_ERROR >= LOG_LEVEL_THRESHOLD
#define log_error(...) log(LOG_LEVEL_ERROR, __VA_ARGS__)
#define log_once_error(...)                                                                                            \
    do                                                                                                                 \
    {                                                                                                                  \
        static bool _once = false;                                                                                     \
        if (!_once)                                                                                                    \
        {                                                                                                              \
            _once = true;                                                                                              \
            log(LOG_LEVEL_ERROR, __VA_ARGS__);                                                                         \
        }                                                                                                              \
    } while (0)
#else
#define log_error(...) (void)0
#endif
        """
        
    #________________________________-.logger.hpp-________________________________#

        self.logger_CMake_conten: str = """
cmake_minimum_required(VERSION 3.14)
project(one_header_logger LANGUAGES CXX)

add_library(one_header_logger INTERFACE)

target_include_directories(one_header_logger INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})

# Allow user to define logging threshold and mutex at compile time
target_compile_definitions(one_header_logger INTERFACE
    $<$<BOOL:${LOG_LEVEL_THRESHOLD}>:LOG_LEVEL_THRESHOLD=${LOG_LEVEL_THRESHOLD}>
    $<$<BOOL:${ENABLE_LOG_MUTEX}>:ENABLE_LOG_MUTEX>
)

# default threshold if none is set
if(NOT DEFINED LOG_LEVEL_THRESHOLD)
    target_compile_definitions(one_header_logger INTERFACE LOG_LEVEL_THRESHOLD=LOG_LEVEL_DEBUG)
endif()
        """
        
    #________________________________-.clang-format-________________________________#
        self.clang_format_conten: str = """
Language: Cpp
BasedOnStyle: Microsoft
AlignTrailingComments: true
BreakBeforeBraces: Custom
BraceWrapping:
    AfterEnum: true
    AfterStruct: true
    AfterClass: true
    AfterFunction: true
    AfterUnion: true
    AfterExternBlock: false
    BeforeCatch: true
    BeforeElse: true
    BeforeLambdaBody: true
    BeforeWhile: false
    AfterNamespace: false
    SplitEmptyFunction: true
IndentWidth: 4
KeepEmptyLinesAtTheStartOfBlocks: false
PointerBindsToType: true
SpacesBeforeTrailingComments: 1
TabWidth: 4
UseTab: Never
IndentCaseLabels: true
NamespaceIndentation: All
AccessModifierOffset: -4
AlignAfterOpenBracket: Align
AlignConsecutiveAssignments: Consecutive
AlignConsecutiveMacros:
    Enabled: true
    AcrossEmptyLines: true
    AcrossComments: false
AllowShortCaseLabelsOnASingleLine: true
AlignEscapedNewlines: Right
AllowShortBlocksOnASingleLine: Always
AllowShortEnumsOnASingleLine: false
AlignConsecutiveDeclarations: true
AlwaysBreakTemplateDeclarations: true
Cpp11BracedListStyle: false
PackConstructorInitializers: Never
AllowShortFunctionsOnASingleLine: Empty
ReflowComments: true
PenaltyBreakComment: 0
PenaltyBreakOpenParenthesis: 1
        """

def is_tool_installed(tool_name: str) -> bool:
    """Check if a tool is installed on the system."""
    try:
        subprocess.run([tool_name, "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        return True
    except (FileNotFoundError, subprocess.CalledProcessError):
        return False

def install_tool(tool_name: str):
    """Attempt to install a tool using the appropriate package manager."""
    try:
        if sys.platform.startswith("linux"):
            if os.path.exists("/usr/bin/pacman"):
                print(f"Installing {tool_name} using pacman...")
                subprocess.run(["sudo", "pacman", "-S", "--noconfirm", tool_name], check=True)
            elif os.path.exists("/usr/bin/yay"):
                print(f"Installing {tool_name} using yay...")
                subprocess.run(["yay", "-S", "--noconfirm", tool_name], check=True)
            elif os.path.exists("/usr/bin/apt-get"):
                print(f"Installing {tool_name} using apt-get...")
                subprocess.run(["sudo", "apt-get", "install", "-y", tool_name], check=True)
            elif os.path.exists("/usr/bin/dnf"):
                print(f"Installing {tool_name} using dnf...")
                subprocess.run(["sudo", "dnf", "install", "-y", tool_name], check=True)
            else:
                print(f"Unknown package manager. Please install {tool_name} manually.")
        elif sys.platform == "darwin":
            print(f"Installing {tool_name} via Homebrew...")
            subprocess.run(["brew", "install", tool_name], check=True)
        elif sys.platform == "win32":
            print(f"Please install {tool_name} manually on Windows.")
        else:
            print(f"Unsupported platform. Please install {tool_name} manually.")
    except subprocess.CalledProcessError as e:
        print(f"Failed to install {tool_name}: {e}")

def check_dependencies():
    """Ensure all necessary tools are installed."""
    tools = ["clang-format", "cmake", "make"]
    for tool in tools:
        if not is_tool_installed(tool):
            print(f"{tool} is not installed.")
            install_tool(tool)

def write_file(file_path: str, content: str = "") -> None:
    with open(file_path, "w", encoding="utf-8") as file:
        file.write(content)

def main(argv: list[str]) -> None:
    
    check_dependencies()
    argc: int = len(argv)
    project_name: str = ""

    if argc != 2:
        print("Please enter project name:")
        project_name = input()
    else:
        project_name = argv[1]
    
    print(f"project name: '{project_name}'")
    
    # Check if the directory already exists
    if os.path.exists(project_name):
        print(f"Error: Directory '{project_name}' already exists.")
        print("Do you want to override? (y/Y/yes)")
        response = input().strip().lower()

        if response in {'y', 'yes'}:
            print("Overriding the existing directory...")
            shutil.rmtree(project_name)
        else:
            print("Operation aborted.")
            return

    project_content = ProjectContent(project_name)
    os.makedirs(project_name)

    # Dictionary of file paths and contents to be written
    root_files: Dict[str, str] = {
        os.path.join(project_name, "main.cpp"): project_content.main_cpp_content,          # root main
        os.path.join(project_name, ".clang-format"): project_content.clang_format_conten,  # root clang-format
        os.path.join(project_name, ".gitignore"): project_content.git_ignore_content,      # root .gitignore
        os.path.join(project_name, "CMakeLists.txt"): project_content.cmake_list_root      # root CMakeLists
    }

    for file_path, content in root_files.items():
        write_file(file_path, content)
     
    # List of directories to create
    directories: List[str] = [
        os.path.join(project_name, "build"),
        os.path.join(project_name, "src"),
        os.path.join(project_name, "include"),
        os.path.join(project_name, "tests"),
        os.path.join(project_name, "logger")
    ]

    for directory in directories:
        os.makedirs(directory, exist_ok=True)

    # Dictionary of additional files to be created
    additional_files: Dict[str, str] = {
        os.path.join(project_name, "src",  f'{project_name}.cpp'): project_content.src_file_content,         # src/ dir c++ file
        os.path.join(project_name, "include",  f'{project_name}.h'): project_content.header_file_content,    # include/ dir header file
        os.path.join(project_name,  "tests", f'{project_name}_test.cpp'): project_content.test_file_content, # test/ dir test.cpp file
        os.path.join(project_name,  "tests", "CMakeLists.txt"): project_content.cmake_list_test_content,      # test/ dir CMakeLists
        os.path.join(project_name,  "logger", "CMakeLists.txt"): project_content.logger_CMake_conten,      # test/ dir CMakeLists
        os.path.join(project_name,  "logger", "logger.hpp"): project_content.logger_hpp_conten      # test/ dir CMakeLists
    }    

    for file_path, content in additional_files.items():
        write_file(file_path, content)
    
if __name__ == '__main__':
    main(sys.argv)